# Dark Tower

## Background
As a teenager in the '80s I had a friend that had Milton Bradley's Dark Tower game.  We loved playing it and I recently picked up a copy off of eBay.  While playing recently, I started really wondering about its internal workings, and after doing a bit of research, I stumbled across Sean Riddle's [TMS1400 page](http://www.seanriddle.com/tms1400.html).

Seeing the work he did there and the ROM dumps that were available, I immediately set out in search of a disassembler for the TMS1400.  After considerable digging, I discovered @paulscottrobson's [Simon2Simon](https://github.com/paulscottrobson/Simon2Simon) project where he had written a TMS1100 disassembler.  Using that (yeah, I should have done some git magic and created a branch, but this is the first I've ever used github), I took it and modified both it and his assembler heavily to support the TMS1400 and some of the things I wanted to accomplish.  This did require taking out some features he had put in and I'll apologize in advance for my lack of python skill.  In spite of my ineptitude at python, I was able to take his code and build a disassembler and its sister assembler to generate a binary that matched the original input.  I can't emphasize enough that he did the vast majority of the heavy lifting.

## The real work
Once I had that, it was just a matter of starting to dig into the assembly code along with the TMS1400 documentation, the various bits of information on Sean's page and the Dark Tower instructions themselves.  This took me reasonably far until I started trying to figure out the physical interactions.  It was then that I discovered that MAME had a built-in debugger and already supported the Dark Tower game.  Visibility into the internal workings of the processor and having a single-step debugger basically made the entire process easy.

# Pieces and parts
The various (imporant) files that make up this repository are:

- `darktower.asm` - The file that was originally generated by the disassembler (`bin/dasm.py`) ; this has been heavily commented by me
- `darktower.lst` - The listing file generated by the assembler (`bin/tasm.py`)
- `darktower.sym` - Symbol file generated by the assembler and taken as an input
- `darktower.bin` - Binary dump from Sean Riddle's site
- `Dark Tower Info.txt` - Various notes I've made while digging through the code
- `Dark Tower RAM usage.xlsx` - Excel spreadsheet representing the TMS1400's RAM and how Dark Tower uses it
- `Dark Tower Documentation/Dark Tower controller Pinout.txt` - Sean's original file with some additional information I've discovered
- `bin/dasm.py` - My version of @paulscottrobson's TMS1100 disassembler heavily modified to disassemble TMS1400 binary data
- `bin/tasm.py` - My version of @paulscottrobson's TMS1100 assembler heavily modified to assemble TMS1400 code (specifically, dasm's output)

# A couple of explanations
## My representation of RAM addressing
The TMS1400 has eight files of 16 4-bit words that are addressed by instructions using the X and Y registers as pointers.  While MAME simply treats the RAM as sequentially-addressed bytes of data, this didn't seem appropriate to me.  In all of my comments as well as the Excel spreadsheet, I refer to RAM addresses in the format of X/Y, where X is the file identifier and Y is the word in that file.

For example, in the AD2B10 routine, I have the following comment:

```
;********************************************************************************
; AD2B10
;
; Perform Base 10 arithmetic on values in scratchpad RAM 4/1-2 and 5/1-2
;
; Add the two-digit base 10 number encoded in 4/1 and 4/2 to the two-digit 
; base 10 number encoded in 5/1 and 5/2 giving a three-digit base-10 number
; encoded in 5/0-2.
;
; For example:   0 1 2     (x means doesn't matter--overwritten)
;              4 x 1 9
;              5 x 2 2
;
; Returns:       0 1 2
;              4 0 1 9
;              5 0 4 1
;********************************************************************************
```
The reference to `RAM 4/1-2` refers to the words referenced when the X register is loaded with a 4 and the Y register is loaded with a 1 and subsequently a 2.
The same applies in the comment about `5/1`--where X=5 and Y=1.  When viewing RAM in MAME, this would refer to address 0x51.

## The assembler file format
I didn't put a ton of effort into the assembler itself.  It basically assumes any characters in the first eight positions are labels.  In the initial pass of the disassembler, labels are generated with either an "L" or an "S" as their first character (long or short respectively) concatenated with the address they represent.  Note the L/S usage is determined by the first time the label is generated.  It's possible that a long branch used once could be targeted by short branches later.  No change to the label would be made.

## The listing file
### Code
Here are the first few lines from the `lst` file in my initial commit:
```
                 1 	
                 2 ; *** Chapter 0 page 0	
                 3 	
0:0:00 000:28    4 S000    ldx   0         	
0:0:01 001:21    5         tma             	
0:0:03 003:71    6         a9aac           	
0:0:07 007:BE    7         br    S03E      	
0:0:0F 00F:61    8 S00F    tcmiy 8         	
0:0:1F 01F:40    9         tcy   0         	
0:0:3F 03F:9B   10         br    S01B      	
0:0:3E 03E:60   11 S03E    tcmiy 0         	
```
The first three colon-delimited values are there to correspond to MAME's representation of addresses in its debugger.  Basically, they are in the format Chapter:Page:Offset.  Note that the TMS1xxx processers do not use a sequential address scheme; this is why addresses run in the goofy order they do.

The second two colon-delimited values are simply the absolute address followed by the opcode.  Following that are the line number and the original assembly source.

### Cross-reference
Following the listing is the cross-reference section:
```
Cross-reference
---------------

LABEL    VALUE	- (DEF) REF(b = BR, c=CALL)
S000     0x0000	- (4) 33(b) 41(b)
S00A     0x000a	- (67) 61(b) 63(b)
S00F     0x000f	- (8) 45(b)
S011     0x0011	- (57) 51(b)
S018     0x0018	- (34) 32(b)
S01B     0x001b	- (48) 10(b)
S01C     0x001c	- (42) 35(b) 40(b)
S026     0x0026	- (62) 56(b)
S033     0x0033	- (25) 22(b)
S03D     0x003d	- (17) 66(b) 72(b) 806(b)
S03E     0x003e	- (11) 7(b)
L040     0x0040	- (77) 26(c) 1369(c)
```
As the headings indicate, the first column is the name of the label, the second column is its value (absolute address).  The subsequent values after the hyphen provide information about the label.  The first value in parenthesis is the line number where the label is defined.  The following values are lines where the label is referenced followed by either a "b" if it was used in a branch (`br`) statement or a "c" if it was used in a call (`call`).
